{"ast":null,"code":"var _ = require(\"./lodash.custom.js\");\n\nvar rewind = require(\"geojson-rewind\"); // see https://wiki.openstreetmap.org/wiki/Overpass_turbo/Polygon_Features\n\n\nvar polygonFeatures = {};\n\nrequire(\"osm-polygon-features\").forEach(function (tags) {\n  if (tags.polygon === \"all\") polygonFeatures[tags.key] = true;else {\n    var list = tags.polygon === \"whitelist\" ? \"included_values\" : \"excluded_values\",\n        tagValuesObj = {};\n    tags.values.forEach(function (value) {\n      tagValuesObj[value] = true;\n    });\n    polygonFeatures[tags.key] = {};\n    polygonFeatures[tags.key][list] = tagValuesObj;\n  }\n});\n\nvar osmtogeojson = {};\n\nosmtogeojson = function (data, options) {\n  options = _.merge({\n    verbose: false,\n    flatProperties: false,\n    uninterestingTags: {\n      \"source\": true,\n      \"source_ref\": true,\n      \"source:ref\": true,\n      \"history\": true,\n      \"attribution\": true,\n      \"created_by\": true,\n      \"tiger:county\": true,\n      \"tiger:tlid\": true,\n      \"tiger:upload_uuid\": true\n    },\n    polygonFeatures: polygonFeatures\n  }, options);\n  var result;\n  if (typeof XMLDocument !== \"undefined\" && data instanceof XMLDocument || typeof XMLDocument === \"undefined\" && data.childNodes) result = _osmXML2geoJSON(data);else result = _overpassJSON2geoJSON(data);\n  return result;\n\n  function _overpassJSON2geoJSON(json) {\n    // sort elements\n    var nodes = new Array();\n    var ways = new Array();\n    var rels = new Array(); // helper functions\n\n    function centerGeometry(object) {\n      var pseudoNode = _.clone(object);\n\n      pseudoNode.lat = object.center.lat;\n      pseudoNode.lon = object.center.lon;\n      pseudoNode.__is_center_placeholder = true;\n      nodes.push(pseudoNode);\n    }\n\n    function boundsGeometry(object) {\n      var pseudoWay = _.clone(object);\n\n      pseudoWay.nodes = [];\n\n      function addPseudoNode(lat, lon, i) {\n        var pseudoNode = {\n          type: \"node\",\n          id: \"_\" + pseudoWay.type + \"/\" + pseudoWay.id + \"bounds\" + i,\n          lat: lat,\n          lon: lon\n        };\n        pseudoWay.nodes.push(pseudoNode.id);\n        nodes.push(pseudoNode);\n      }\n\n      addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.minlon, 1);\n      addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.minlon, 2);\n      addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.maxlon, 3);\n      addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.maxlon, 4);\n      pseudoWay.nodes.push(pseudoWay.nodes[0]);\n      pseudoWay.__is_bounds_placeholder = true;\n      ways.push(pseudoWay);\n    }\n\n    function fullGeometryWay(way) {\n      function addFullGeometryNode(lat, lon, id) {\n        var geometryNode = {\n          type: \"node\",\n          id: id,\n          lat: lat,\n          lon: lon,\n          __is_uninteresting: true\n        };\n        nodes.push(geometryNode);\n      }\n\n      if (!_.isArray(way.nodes)) {\n        way.nodes = way.geometry.map(function (nd) {\n          if (nd !== null) // have to skip ref-less nodes\n            return \"_anonymous@\" + nd.lat + \"/\" + nd.lon;else return \"_anonymous@unknown_location\";\n        });\n      }\n\n      way.geometry.forEach(function (nd, i) {\n        if (nd) {\n          addFullGeometryNode(nd.lat, nd.lon, way.nodes[i]);\n        }\n      });\n    }\n\n    function fullGeometryRelation(rel) {\n      function addFullGeometryNode(lat, lon, id) {\n        var geometryNode = {\n          type: \"node\",\n          id: id,\n          lat: lat,\n          lon: lon\n        };\n        nodes.push(geometryNode);\n      }\n\n      function addFullGeometryWay(geometry, id) {\n        // shared multipolygon ways cannot be defined multiple times with the same id.\n        if (ways.some(function (way) {\n          // todo: this is slow :(\n          return way.type == \"way\" && way.id == id;\n        })) return;\n        var geometryWay = {\n          type: \"way\",\n          id: id,\n          nodes: []\n        };\n\n        function addFullGeometryWayPseudoNode(lat, lon) {\n          // todo? do not save the same pseudo node multiple times\n          var geometryPseudoNode = {\n            type: \"node\",\n            id: \"_anonymous@\" + lat + \"/\" + lon,\n            lat: lat,\n            lon: lon,\n            __is_uninteresting: true\n          };\n          geometryWay.nodes.push(geometryPseudoNode.id);\n          nodes.push(geometryPseudoNode);\n        }\n\n        geometry.forEach(function (nd) {\n          if (nd) {\n            addFullGeometryWayPseudoNode(nd.lat, nd.lon);\n          } else {\n            geometryWay.nodes.push(undefined);\n          }\n        });\n        ways.push(geometryWay);\n      }\n\n      rel.members.forEach(function (member, i) {\n        if (member.type == \"node\") {\n          if (member.lat) {\n            addFullGeometryNode(member.lat, member.lon, member.ref);\n          }\n        } else if (member.type == \"way\") {\n          if (member.geometry) {\n            member.ref = \"_fullGeom\" + member.ref;\n            addFullGeometryWay(member.geometry, member.ref);\n          }\n        }\n      });\n    } // create copies of individual json objects to make sure the original data doesn't get altered\n    // todo: cloning is slow: see if this can be done differently!\n\n\n    for (var i = 0; i < json.elements.length; i++) {\n      switch (json.elements[i].type) {\n        case \"node\":\n          var node = json.elements[i];\n          nodes.push(node);\n          break;\n\n        case \"way\":\n          var way = _.clone(json.elements[i]);\n\n          way.nodes = _.clone(way.nodes);\n          ways.push(way);\n          if (way.center) centerGeometry(way);\n          if (way.geometry) fullGeometryWay(way);else if (way.bounds) boundsGeometry(way);\n          break;\n\n        case \"relation\":\n          var rel = _.clone(json.elements[i]);\n\n          rel.members = _.clone(rel.members);\n          rels.push(rel);\n          var has_full_geometry = rel.members && rel.members.some(function (member) {\n            return member.type == \"node\" && member.lat || member.type == \"way\" && member.geometry && member.geometry.length > 0;\n          });\n          if (rel.center) centerGeometry(rel);\n          if (has_full_geometry) fullGeometryRelation(rel);else if (rel.bounds) boundsGeometry(rel);\n          break;\n\n        default: // type=area (from coord-query) is an example for this case.\n\n      }\n    }\n\n    return _convert2geoJSON(nodes, ways, rels);\n  }\n\n  function _osmXML2geoJSON(xml) {\n    // sort elements\n    var nodes = new Array();\n    var ways = new Array();\n    var rels = new Array(); // helper function\n\n    function copy_attribute(x, o, attr) {\n      if (x.hasAttribute(attr)) o[attr] = x.getAttribute(attr);\n    }\n\n    function centerGeometry(object, centroid) {\n      var pseudoNode = _.clone(object);\n\n      copy_attribute(centroid, pseudoNode, 'lat');\n      copy_attribute(centroid, pseudoNode, 'lon');\n      pseudoNode.__is_center_placeholder = true;\n      nodes.push(pseudoNode);\n    }\n\n    function boundsGeometry(object, bounds) {\n      var pseudoWay = _.clone(object);\n\n      pseudoWay.nodes = [];\n\n      function addPseudoNode(lat, lon, i) {\n        var pseudoNode = {\n          type: \"node\",\n          id: \"_\" + pseudoWay.type + \"/\" + pseudoWay.id + \"bounds\" + i,\n          lat: lat,\n          lon: lon\n        };\n        pseudoWay.nodes.push(pseudoNode.id);\n        nodes.push(pseudoNode);\n      }\n\n      addPseudoNode(bounds.getAttribute('minlat'), bounds.getAttribute('minlon'), 1);\n      addPseudoNode(bounds.getAttribute('maxlat'), bounds.getAttribute('minlon'), 2);\n      addPseudoNode(bounds.getAttribute('maxlat'), bounds.getAttribute('maxlon'), 3);\n      addPseudoNode(bounds.getAttribute('minlat'), bounds.getAttribute('maxlon'), 4);\n      pseudoWay.nodes.push(pseudoWay.nodes[0]);\n      pseudoWay.__is_bounds_placeholder = true;\n      ways.push(pseudoWay);\n    }\n\n    function fullGeometryWay(way, nds) {\n      function addFullGeometryNode(lat, lon, id) {\n        var geometryNode = {\n          type: \"node\",\n          id: id,\n          lat: lat,\n          lon: lon,\n          __is_uninteresting: true\n        };\n        nodes.push(geometryNode);\n        return geometryNode.id;\n      }\n\n      if (!_.isArray(way.nodes)) {\n        way.nodes = [];\n\n        _.each(nds, function (nd, i) {\n          way.nodes.push(\"_anonymous@\" + nd.getAttribute('lat') + \"/\" + nd.getAttribute('lon'));\n        });\n      }\n\n      _.each(nds, function (nd, i) {\n        if (nd.getAttribute('lat')) {\n          addFullGeometryNode(nd.getAttribute('lat'), nd.getAttribute('lon'), way.nodes[i]);\n        }\n      });\n    }\n\n    function fullGeometryRelation(rel, members) {\n      function addFullGeometryNode(lat, lon, id) {\n        var geometryNode = {\n          type: \"node\",\n          id: id,\n          lat: lat,\n          lon: lon\n        };\n        nodes.push(geometryNode);\n      }\n\n      function addFullGeometryWay(nds, id) {\n        // shared multipolygon ways cannot be defined multiple times with the same id.\n        if (ways.some(function (way) {\n          // todo: this is slow :(\n          return way.type == \"way\" && way.id == id;\n        })) return;\n        var geometryWay = {\n          type: \"way\",\n          id: id,\n          nodes: []\n        };\n\n        function addFullGeometryWayPseudoNode(lat, lon) {\n          // todo? do not save the same pseudo node multiple times\n          var geometryPseudoNode = {\n            type: \"node\",\n            id: \"_anonymous@\" + lat + \"/\" + lon,\n            lat: lat,\n            lon: lon,\n            __is_uninteresting: true\n          };\n          geometryWay.nodes.push(geometryPseudoNode.id);\n          nodes.push(geometryPseudoNode);\n        }\n\n        _.each(nds, function (nd) {\n          if (nd.getAttribute('lat')) {\n            addFullGeometryWayPseudoNode(nd.getAttribute('lat'), nd.getAttribute('lon'));\n          } else {\n            geometryWay.nodes.push(undefined);\n          }\n        });\n\n        ways.push(geometryWay);\n      }\n\n      _.each(members, function (member, i) {\n        if (rel.members[i].type == \"node\") {\n          if (member.getAttribute('lat')) {\n            addFullGeometryNode(member.getAttribute('lat'), member.getAttribute('lon'), rel.members[i].ref);\n          }\n        } else if (rel.members[i].type == \"way\") {\n          if (member.getElementsByTagName('nd').length > 0) {\n            rel.members[i].ref = \"_fullGeom\" + rel.members[i].ref;\n            addFullGeometryWay(member.getElementsByTagName('nd'), rel.members[i].ref);\n          }\n        }\n      });\n    } // nodes\n\n\n    _.each(xml.getElementsByTagName('node'), function (node, i) {\n      var tags = {};\n\n      _.each(node.getElementsByTagName('tag'), function (tag) {\n        tags[tag.getAttribute('k')] = tag.getAttribute('v');\n      });\n\n      var nodeObject = {\n        'type': 'node'\n      };\n      copy_attribute(node, nodeObject, 'id');\n      copy_attribute(node, nodeObject, 'lat');\n      copy_attribute(node, nodeObject, 'lon');\n      copy_attribute(node, nodeObject, 'version');\n      copy_attribute(node, nodeObject, 'timestamp');\n      copy_attribute(node, nodeObject, 'changeset');\n      copy_attribute(node, nodeObject, 'uid');\n      copy_attribute(node, nodeObject, 'user');\n      if (!_.isEmpty(tags)) nodeObject.tags = tags;\n      nodes.push(nodeObject);\n    }); // ways\n\n\n    var centroid, bounds;\n\n    _.each(xml.getElementsByTagName('way'), function (way, i) {\n      var tags = {};\n      var wnodes = [];\n\n      _.each(way.getElementsByTagName('tag'), function (tag) {\n        tags[tag.getAttribute('k')] = tag.getAttribute('v');\n      });\n\n      var has_full_geometry = false;\n\n      _.each(way.getElementsByTagName('nd'), function (nd, i) {\n        var id;\n        if (id = nd.getAttribute('ref')) wnodes[i] = id;\n        if (!has_full_geometry && nd.getAttribute('lat')) has_full_geometry = true;\n      });\n\n      var wayObject = {\n        \"type\": \"way\"\n      };\n      copy_attribute(way, wayObject, 'id');\n      copy_attribute(way, wayObject, 'version');\n      copy_attribute(way, wayObject, 'timestamp');\n      copy_attribute(way, wayObject, 'changeset');\n      copy_attribute(way, wayObject, 'uid');\n      copy_attribute(way, wayObject, 'user');\n      if (wnodes.length > 0) wayObject.nodes = wnodes;\n      if (!_.isEmpty(tags)) wayObject.tags = tags;\n      if (centroid = way.getElementsByTagName('center')[0]) centerGeometry(wayObject, centroid);\n      if (has_full_geometry) fullGeometryWay(wayObject, way.getElementsByTagName('nd'));else if (bounds = way.getElementsByTagName('bounds')[0]) boundsGeometry(wayObject, bounds);\n      ways.push(wayObject);\n    }); // relations\n\n\n    _.each(xml.getElementsByTagName('relation'), function (relation, i) {\n      var tags = {};\n      var members = [];\n\n      _.each(relation.getElementsByTagName('tag'), function (tag) {\n        tags[tag.getAttribute('k')] = tag.getAttribute('v');\n      });\n\n      var has_full_geometry = false;\n\n      _.each(relation.getElementsByTagName('member'), function (member, i) {\n        members[i] = {};\n        copy_attribute(member, members[i], 'ref');\n        copy_attribute(member, members[i], 'role');\n        copy_attribute(member, members[i], 'type');\n        if (!has_full_geometry && members[i].type == 'node' && member.getAttribute('lat') || members[i].type == 'way' && member.getElementsByTagName('nd').length > 0) has_full_geometry = true;\n      });\n\n      var relObject = {\n        \"type\": \"relation\"\n      };\n      copy_attribute(relation, relObject, 'id');\n      copy_attribute(relation, relObject, 'version');\n      copy_attribute(relation, relObject, 'timestamp');\n      copy_attribute(relation, relObject, 'changeset');\n      copy_attribute(relation, relObject, 'uid');\n      copy_attribute(relation, relObject, 'user');\n      if (members.length > 0) relObject.members = members;\n      if (!_.isEmpty(tags)) relObject.tags = tags;\n      if (centroid = relation.getElementsByTagName('center')[0]) centerGeometry(relObject, centroid);\n      if (has_full_geometry) fullGeometryRelation(relObject, relation.getElementsByTagName('member'));else if (bounds = relation.getElementsByTagName('bounds')[0]) boundsGeometry(relObject, bounds);\n      rels.push(relObject);\n    });\n\n    return _convert2geoJSON(nodes, ways, rels);\n  }\n\n  function _convert2geoJSON(nodes, ways, rels) {\n    // helper function that checks if there are any tags other than \"created_by\", \"source\", etc. or any tag provided in ignore_tags\n    function has_interesting_tags(t, ignore_tags) {\n      if (typeof ignore_tags !== \"object\") ignore_tags = {};\n      if (typeof options.uninterestingTags === \"function\") return !options.uninterestingTags(t, ignore_tags);\n\n      for (var k in t) if (!(options.uninterestingTags[k] === true) && !(ignore_tags[k] === true || ignore_tags[k] === t[k])) return true;\n\n      return false;\n    }\n\n    ; // helper function to extract meta information\n\n    function build_meta_information(object) {\n      var res = {\n        \"timestamp\": object.timestamp,\n        \"version\": object.version,\n        \"changeset\": object.changeset,\n        \"user\": object.user,\n        \"uid\": object.uid\n      };\n\n      for (var k in res) if (res[k] === undefined) delete res[k];\n\n      return res;\n    } // some data processing (e.g. filter nodes only used for ways)\n\n\n    var nodeids = new Object();\n\n    for (var i = 0; i < nodes.length; i++) {\n      if (nodes[i].lat === undefined) {\n        if (options.verbose) console.warn('Node', nodes[i].type + '/' + nodes[i].id, 'ignored because it has no coordinates');\n        continue; // ignore nodes without coordinates (e.g. returned by an ids_only query)\n      }\n\n      nodeids[nodes[i].id] = nodes[i];\n    }\n\n    var poinids = new Object();\n\n    for (var i = 0; i < nodes.length; i++) {\n      if (typeof nodes[i].tags != 'undefined' && has_interesting_tags(nodes[i].tags)) // this checks if the node has any tags other than \"created_by\"\n        poinids[nodes[i].id] = true;\n    }\n\n    for (var i = 0; i < rels.length; i++) {\n      if (!_.isArray(rels[i].members)) {\n        if (options.verbose) console.warn('Relation', rels[i].type + '/' + rels[i].id, 'ignored because it has no members');\n        continue; // ignore relations without members (e.g. returned by an ids_only query)\n      }\n\n      for (var j = 0; j < rels[i].members.length; j++) {\n        if (rels[i].members[j].type == \"node\") poinids[rels[i].members[j].ref] = true;\n      }\n    }\n\n    var wayids = new Object();\n    var waynids = new Object();\n\n    for (var i = 0; i < ways.length; i++) {\n      if (!_.isArray(ways[i].nodes)) {\n        if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'ignored because it has no nodes');\n        continue; // ignore ways without nodes (e.g. returned by an ids_only query)\n      }\n\n      wayids[ways[i].id] = ways[i];\n\n      for (var j = 0; j < ways[i].nodes.length; j++) {\n        waynids[ways[i].nodes[j]] = true;\n        ways[i].nodes[j] = nodeids[ways[i].nodes[j]];\n      }\n    }\n\n    var pois = new Array();\n\n    for (var i = 0; i < nodes.length; i++) {\n      if ((!waynids[nodes[i].id] || poinids[nodes[i].id]) && !nodes[i].__is_uninteresting) pois.push(nodes[i]);\n    }\n\n    var relids = new Array();\n\n    for (var i = 0; i < rels.length; i++) {\n      if (!_.isArray(rels[i].members)) {\n        if (options.verbose) console.warn('Relation', rels[i].type + '/' + rels[i].id, 'ignored because it has no members');\n        continue; // ignore relations without members (e.g. returned by an ids_only query)\n      }\n\n      relids[rels[i].id] = rels[i];\n    }\n\n    var relsmap = {\n      node: {},\n      way: {},\n      relation: {}\n    };\n\n    for (var i = 0; i < rels.length; i++) {\n      if (!_.isArray(rels[i].members)) {\n        if (options.verbose) console.warn('Relation', rels[i].type + '/' + rels[i].id, 'ignored because it has no members');\n        continue; // ignore relations without members (e.g. returned by an ids_only query)\n      }\n\n      for (var j = 0; j < rels[i].members.length; j++) {\n        var m_type = rels[i].members[j].type;\n        var m_ref = rels[i].members[j].ref;\n\n        if (typeof m_ref !== \"number\") {\n          // de-namespace full geometry content\n          m_ref = m_ref.replace(\"_fullGeom\", \"\");\n        }\n\n        if (!relsmap[m_type]) {\n          if (options.verbose) console.warn('Relation', rels[i].type + '/' + rels[i].id, 'member', m_type + '/' + m_ref, 'ignored because it has an invalid type');\n          continue;\n        }\n\n        if (typeof relsmap[m_type][m_ref] === \"undefined\") relsmap[m_type][m_ref] = [];\n        relsmap[m_type][m_ref].push({\n          \"role\": rels[i].members[j].role,\n          \"rel\": rels[i].id,\n          \"reltags\": rels[i].tags\n        });\n      }\n    } // construct geojson\n\n\n    var geojson;\n    var geojsonnodes = {\n      \"type\": \"FeatureCollection\",\n      \"features\": new Array()\n    };\n\n    for (i = 0; i < pois.length; i++) {\n      if (typeof pois[i].lon == \"undefined\" || typeof pois[i].lat == \"undefined\") {\n        if (options.verbose) console.warn('POI', pois[i].type + '/' + pois[i].id, 'ignored because it lacks coordinates');\n        continue; // lon and lat are required for showing a point\n      }\n\n      var feature = {\n        \"type\": \"Feature\",\n        \"id\": pois[i].type + \"/\" + pois[i].id,\n        \"properties\": {\n          \"type\": pois[i].type,\n          \"id\": pois[i].id,\n          \"tags\": pois[i].tags || {},\n          \"relations\": relsmap[\"node\"][pois[i].id] || [],\n          \"meta\": build_meta_information(pois[i])\n        },\n        \"geometry\": {\n          \"type\": \"Point\",\n          \"coordinates\": [+pois[i].lon, +pois[i].lat]\n        }\n      };\n      if (pois[i].__is_center_placeholder) feature.properties[\"geometry\"] = \"center\";\n      geojsonnodes.features.push(feature);\n    }\n\n    var geojsonlines = {\n      \"type\": \"FeatureCollection\",\n      \"features\": new Array()\n    };\n    var geojsonpolygons = {\n      \"type\": \"FeatureCollection\",\n      \"features\": new Array()\n    }; // process multipolygons\n\n    for (var i = 0; i < rels.length; i++) {\n      if (typeof rels[i].tags != \"undefined\" && (rels[i].tags[\"type\"] == \"multipolygon\" || rels[i].tags[\"type\"] == \"boundary\")) {\n        if (!_.isArray(rels[i].members)) {\n          if (options.verbose) console.warn('Multipolygon', rels[i].type + '/' + rels[i].id, 'ignored because it has no members');\n          continue; // ignore relations without members (e.g. returned by an ids_only query)\n        }\n\n        var outer_count = 0;\n\n        for (var j = 0; j < rels[i].members.length; j++) if (rels[i].members[j].role == \"outer\") outer_count++;else if (options.verbose && rels[i].members[j].role != \"inner\") console.warn('Multipolygon', rels[i].type + '/' + rels[i].id, 'member', rels[i].members[j].type + '/' + rels[i].members[j].ref, 'ignored because it has an invalid role: \"' + rels[i].members[j].role + '\"');\n\n        rels[i].members.forEach(function (m) {\n          if (wayids[m.ref]) {\n            // this even works in the following corner case:\n            // a multipolygon amenity=xxx with outer line tagged amenity=yyy\n            // see https://github.com/tyrasd/osmtogeojson/issues/7\n            if (m.role === \"outer\" && !has_interesting_tags(wayids[m.ref].tags, rels[i].tags)) wayids[m.ref].is_multipolygon_outline = true;\n            if (m.role === \"inner\" && !has_interesting_tags(wayids[m.ref].tags)) wayids[m.ref].is_multipolygon_outline = true;\n          }\n        });\n\n        if (outer_count == 0) {\n          if (options.verbose) console.warn('Multipolygon relation', rels[i].type + '/' + rels[i].id, 'ignored because it has no outer ways');\n          continue; // ignore multipolygons without outer ways\n        }\n\n        var simple_mp = false;\n        var mp_geometry = '';\n        if (outer_count == 1 && !has_interesting_tags(rels[i].tags, {\n          \"type\": true\n        })) simple_mp = true;\n        var feature = null;\n\n        if (!simple_mp) {\n          feature = construct_multipolygon(rels[i], rels[i]);\n        } else {\n          // simple multipolygon\n          var outer_way = rels[i].members.filter(function (m) {\n            return m.role === \"outer\";\n          })[0];\n          outer_way = wayids[outer_way.ref];\n\n          if (outer_way === undefined) {\n            if (options.verbose) console.warn('Multipolygon relation', rels[i].type + '/' + rels[i].id, 'ignored because outer way', outer_way.type + '/' + outer_way.ref, 'is missing');\n            continue; // abort if outer way object is not present\n          }\n\n          outer_way.is_multipolygon_outline = true;\n          feature = construct_multipolygon(outer_way, rels[i]);\n        }\n\n        if (feature === false) {\n          if (options.verbose) console.warn('Multipolygon relation', rels[i].type + '/' + rels[i].id, 'ignored because it has invalid geometry');\n          continue; // abort if feature could not be constructed\n        }\n\n        geojsonpolygons.features.push(feature);\n\n        function construct_multipolygon(tag_object, rel) {\n          var is_tainted = false;\n          var mp_geometry = simple_mp ? 'way' : 'relation',\n              mp_id = typeof tag_object.id === \"number\" ? tag_object.id : +tag_object.id.replace(\"_fullGeom\", \"\"); // prepare mp members\n\n          var members;\n          members = rel.members.filter(function (m) {\n            return m.type === \"way\";\n          });\n          members = members.map(function (m) {\n            var way = wayids[m.ref];\n\n            if (way === undefined) {\n              // check for missing ways\n              if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'tainted by a missing way', m.type + '/' + m.ref);\n              is_tainted = true;\n              return;\n            }\n\n            return {\n              // TODO: this is slow! :(\n              id: m.ref,\n              role: m.role || \"outer\",\n              way: way,\n              nodes: way.nodes.filter(function (n) {\n                if (n !== undefined) return true;\n                is_tainted = true;\n                if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'tainted by a way', m.type + '/' + m.ref, 'with a missing node');\n                return false;\n              })\n            };\n          });\n          members = _.compact(members); // construct outer and inner rings\n\n          var outers, inners;\n\n          function join(ways) {\n            var _first = function (arr) {\n              return arr[0];\n            };\n\n            var _last = function (arr) {\n              return arr[arr.length - 1];\n            }; // stolen from iD/relation.js\n\n\n            var joined = [],\n                current,\n                first,\n                last,\n                i,\n                how,\n                what;\n\n            while (ways.length) {\n              current = ways.pop().nodes.slice();\n              joined.push(current);\n\n              while (ways.length && _first(current) !== _last(current)) {\n                first = _first(current);\n                last = _last(current);\n\n                for (i = 0; i < ways.length; i++) {\n                  what = ways[i].nodes;\n\n                  if (last === _first(what)) {\n                    how = current.push;\n                    what = what.slice(1);\n                    break;\n                  } else if (last === _last(what)) {\n                    how = current.push;\n                    what = what.slice(0, -1).reverse();\n                    break;\n                  } else if (first == _last(what)) {\n                    how = current.unshift;\n                    what = what.slice(0, -1);\n                    break;\n                  } else if (first == _first(what)) {\n                    how = current.unshift;\n                    what = what.slice(1).reverse();\n                    break;\n                  } else {\n                    what = how = null;\n                  }\n                }\n\n                if (!what) {\n                  if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains unclosed ring geometry');\n                  break; // Invalid geometry (dangling way, unclosed ring)\n                }\n\n                ways.splice(i, 1);\n                how.apply(current, what);\n              }\n            }\n\n            return joined;\n          }\n\n          outers = join(members.filter(function (m) {\n            return m.role === \"outer\";\n          }));\n          inners = join(members.filter(function (m) {\n            return m.role === \"inner\";\n          })); // sort rings\n\n          var mp;\n\n          function findOuter(inner) {\n            var polygonIntersectsPolygon = function (outer, inner) {\n              for (var i = 0; i < inner.length; i++) if (pointInPolygon(inner[i], outer)) return true;\n\n              return false;\n            };\n\n            var mapCoordinates = function (from) {\n              return from.map(function (n) {\n                return [+n.lat, +n.lon];\n              });\n            }; // stolen from iD/geo.js,\n            // based on https://github.com/substack/point-in-polygon,\n            // ray-casting algorithm based on http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n\n            var pointInPolygon = function (point, polygon) {\n              var x = point[0],\n                  y = point[1],\n                  inside = false;\n\n              for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n                var xi = polygon[i][0],\n                    yi = polygon[i][1];\n                var xj = polygon[j][0],\n                    yj = polygon[j][1];\n                var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n                if (intersect) inside = !inside;\n              }\n\n              return inside;\n            }; // stolen from iD/relation.js\n\n\n            var o, outer; // todo: all this coordinate mapping makes this unneccesarily slow.\n            // see the \"todo: this is slow! :(\" above.\n\n            inner = mapCoordinates(inner);\n            /*for (o = 0; o < outers.length; o++) {\n              outer = mapCoordinates(outers[o]);\n              if (polygonContainsPolygon(outer, inner))\n                return o;\n            }*/\n\n            for (o = 0; o < outers.length; o++) {\n              outer = mapCoordinates(outers[o]);\n              if (polygonIntersectsPolygon(outer, inner)) return o;\n            }\n          }\n\n          mp = outers.map(function (o) {\n            return [o];\n          });\n\n          for (var j = 0; j < inners.length; j++) {\n            var o = findOuter(inners[j]);\n            if (o !== undefined) mp[o].push(inners[j]);else if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains an inner ring with no containing outer'); // so, no outer ring for this inner ring is found.\n            // We're going to ignore holes in empty space.\n\n            ;\n          } // sanitize mp-coordinates (remove empty clusters or rings, {lat,lon,...} to [lon,lat]\n\n\n          var mp_coords = [];\n          mp_coords = _.compact(mp.map(function (cluster) {\n            var cl = _.compact(cluster.map(function (ring) {\n              if (ring.length < 4) {\n                // todo: is this correct: ring.length < 4 ?\n                if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains a ring with less than four nodes');\n                return;\n              }\n\n              return _.compact(ring.map(function (node) {\n                return [+node.lon, +node.lat];\n              }));\n            }));\n\n            if (cl.length == 0) {\n              if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains an empty ring cluster');\n              return;\n            }\n\n            return cl;\n          }));\n\n          if (mp_coords.length == 0) {\n            if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'contains no coordinates');\n            return false; // ignore multipolygons without coordinates\n          }\n\n          var mp_type = \"MultiPolygon\";\n\n          if (mp_coords.length === 1) {\n            mp_type = \"Polygon\";\n            mp_coords = mp_coords[0];\n          } // mp parsed, now construct the geoJSON\n\n\n          var feature = {\n            \"type\": \"Feature\",\n            \"id\": tag_object.type + \"/\" + mp_id,\n            \"properties\": {\n              \"type\": tag_object.type,\n              \"id\": mp_id,\n              \"tags\": tag_object.tags || {},\n              \"relations\": relsmap[tag_object.type][tag_object.id] || [],\n              \"meta\": build_meta_information(tag_object)\n            },\n            \"geometry\": {\n              \"type\": mp_type,\n              \"coordinates\": mp_coords\n            }\n          };\n\n          if (is_tainted) {\n            if (options.verbose) console.warn('Multipolygon', mp_geometry + '/' + mp_id, 'is tainted');\n            feature.properties[\"tainted\"] = true;\n          }\n\n          return feature;\n        }\n      }\n    } // process lines and polygons\n\n\n    for (var i = 0; i < ways.length; i++) {\n      if (!_.isArray(ways[i].nodes)) {\n        if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'ignored because it has no nodes');\n        continue; // ignore ways without nodes (e.g. returned by an ids_only query)\n      }\n\n      if (ways[i].is_multipolygon_outline) continue; // ignore ways which are already rendered as (part of) a multipolygon\n\n      if (typeof ways[i].id !== \"number\") {\n        // remove full geometry namespace for output\n        ways[i].id = +ways[i].id.replace(\"_fullGeom\", \"\");\n      }\n\n      ways[i].tainted = false;\n      ways[i].hidden = false;\n      var coords = new Array();\n\n      for (j = 0; j < ways[i].nodes.length; j++) {\n        if (typeof ways[i].nodes[j] == \"object\") coords.push([+ways[i].nodes[j].lon, +ways[i].nodes[j].lat]);else {\n          if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'is tainted by an invalid node');\n          ways[i].tainted = true;\n        }\n      }\n\n      if (coords.length <= 1) {\n        // invalid way geometry\n        if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'ignored because it contains too few nodes');\n        continue;\n      }\n\n      var way_type = \"LineString\"; // default\n\n      if (typeof ways[i].nodes[0] != \"undefined\" && // way has its nodes loaded\n      ways[i].nodes[0] === ways[i].nodes[ways[i].nodes.length - 1] && ( // ... and forms a closed ring\n      typeof ways[i].tags != \"undefined\" && // ... and has tags\n      _isPolygonFeature(ways[i].tags) // ... and tags say it is a polygon\n      || // or is a placeholder for a bounds geometry\n      ways[i].__is_bounds_placeholder)) {\n        way_type = \"Polygon\";\n        coords = [coords];\n      }\n\n      var feature = {\n        \"type\": \"Feature\",\n        \"id\": ways[i].type + \"/\" + ways[i].id,\n        \"properties\": {\n          \"type\": ways[i].type,\n          \"id\": ways[i].id,\n          \"tags\": ways[i].tags || {},\n          \"relations\": relsmap[\"way\"][ways[i].id] || [],\n          \"meta\": build_meta_information(ways[i])\n        },\n        \"geometry\": {\n          \"type\": way_type,\n          \"coordinates\": coords\n        }\n      };\n\n      if (ways[i].tainted) {\n        if (options.verbose) console.warn('Way', ways[i].type + '/' + ways[i].id, 'is tainted');\n        feature.properties[\"tainted\"] = true;\n      }\n\n      if (ways[i].__is_bounds_placeholder) feature.properties[\"geometry\"] = \"bounds\";\n      if (way_type == \"LineString\") geojsonlines.features.push(feature);else geojsonpolygons.features.push(feature);\n    }\n\n    geojson = {\n      \"type\": \"FeatureCollection\",\n      \"features\": []\n    };\n    geojson.features = geojson.features.concat(geojsonpolygons.features);\n    geojson.features = geojson.features.concat(geojsonlines.features);\n    geojson.features = geojson.features.concat(geojsonnodes.features); // optionally, flatten properties\n\n    if (options.flatProperties) {\n      geojson.features.forEach(function (f) {\n        f.properties = _.merge(f.properties.meta, f.properties.tags, {\n          id: f.properties.type + \"/\" + f.properties.id\n        });\n      });\n    } // fix polygon winding\n\n\n    geojson = rewind(geojson, true\n    /*remove for geojson-rewind >0.1.0*/\n    );\n    return geojson;\n  }\n\n  function _isPolygonFeature(tags) {\n    var polygonFeatures = options.polygonFeatures;\n    if (typeof polygonFeatures === \"function\") return polygonFeatures(tags); // explicitely tagged non-areas\n\n    if (tags['area'] === 'no') return false; // assuming that a typical OSM way has in average less tags than\n    // the polygonFeatures list, this way around should be faster\n\n    for (var key in tags) {\n      var val = tags[key];\n      var pfk = polygonFeatures[key]; // continue with next if tag is unknown or not \"categorizing\"\n\n      if (typeof pfk === 'undefined') continue; // continue with next if tag is explicitely un-set (\"building=no\")\n\n      if (val === 'no') continue; // check polygon features for: general acceptance, included or excluded values\n\n      if (pfk === true) return true;\n      if (pfk.included_values && pfk.included_values[val] === true) return true;\n      if (pfk.excluded_values && pfk.excluded_values[val] !== true) return true;\n    } // if no tags matched, this ain't no area.\n\n\n    return false;\n  }\n}; // for backwards compatibility\n\n\nosmtogeojson.toGeojson = osmtogeojson;\nmodule.exports = osmtogeojson;","map":null,"metadata":{},"sourceType":"script"}