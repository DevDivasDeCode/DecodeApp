{"ast":null,"code":"/**\n * @license\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash exports=\"node\" include=\"clone,merge,isEmpty,isArray,compact,each\" -d`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n;\n(function () {\n  /** Used to pool arrays and objects used internally */\n  var arrayPool = [];\n  /** Used internally to indicate various things */\n\n  var indicatorObject = {};\n  /** Used as the max size of the `arrayPool` and `objectPool` */\n\n  var maxPoolSize = 40;\n  /** Used to match regexp flags from their coerced string values */\n\n  var reFlags = /\\w*$/;\n  /** Used to detected named functions */\n\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n  /** Used to detect functions containing a `this` reference */\n\n  var reThis = /\\bthis\\b/;\n  /** Used to fix the JScript [[DontEnum]] bug */\n\n  var shadowedProps = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];\n  /** `Object#toString` result shortcuts */\n\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      errorClass = '[object Error]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n  /** Used to identify object classifications that `_.clone` supports */\n\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n  /** Used as the property descriptor for `__bindData__` */\n\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n  /** Used as the data object for `iteratorTemplate` */\n\n  var iteratorData = {\n    'args': '',\n    'array': null,\n    'bottom': '',\n    'firstArg': '',\n    'init': '',\n    'keys': null,\n    'loop': '',\n    'shadowedProps': null,\n    'support': null,\n    'top': '',\n    'useHas': false\n  };\n  /** Used to determine if values are of the language type Object */\n\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n  /** Used as a reference to the global object */\n\n  var root = objectTypes[typeof window] && window || this;\n  /** Detect free variable `exports` */\n\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n  /** Detect free variable `module` */\n\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n  /** Detect the popular CommonJS extension `module.exports` */\n\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n\n  var freeGlobal = objectTypes[typeof global] && global;\n\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Gets an array from the array pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Array} The array from the pool.\n   */\n\n\n  function getArray() {\n    return arrayPool.pop() || [];\n  }\n  /**\n   * Checks if `value` is a DOM node in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.\n   */\n\n\n  function isNode(value) {\n    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`\n    // methods that are `typeof` \"string\" and still can coerce nodes to strings\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\n  }\n  /**\n   * Releases the given array back to the array pool.\n   *\n   * @private\n   * @param {Array} [array] The array to release.\n   */\n\n\n  function releaseArray(array) {\n    array.length = 0;\n\n    if (arrayPool.length < maxPoolSize) {\n      arrayPool.push(array);\n    }\n  }\n  /**\n   * Slices the `collection` from the `start` index up to, but not including,\n   * the `end` index.\n   *\n   * Note: This function is used instead of `Array#slice` to support node lists\n   * in IE < 9 and to ensure dense arrays are returned.\n   *\n   * @private\n   * @param {Array|Object|string} collection The collection to slice.\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array} Returns the new array.\n   */\n\n\n  function slice(array, start, end) {\n    start || (start = 0);\n\n    if (typeof end == 'undefined') {\n      end = array ? array.length : 0;\n    }\n\n    var index = -1,\n        length = end - start || 0,\n        result = Array(length < 0 ? 0 : length);\n\n    while (++index < length) {\n      result[index] = array[start + index];\n    }\n\n    return result;\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Used for `Array` method references.\n   *\n   * Normally `Array.prototype` would suffice, however, using an array literal\n   * avoids issues in Narwhal.\n   */\n\n\n  var arrayRef = [];\n  /** Used for native method references */\n\n  var errorProto = Error.prototype,\n      objectProto = Object.prototype,\n      stringProto = String.prototype;\n  /** Used to resolve the internal [[Class]] of values */\n\n  var toString = objectProto.toString;\n  /** Used to detect if a method is native */\n\n  var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&').replace(/toString| for [^\\]]+/g, '.*?') + '$');\n  /** Native method shortcuts */\n\n  var fnToString = Function.prototype.toString,\n      getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n      hasOwnProperty = objectProto.hasOwnProperty,\n      push = arrayRef.push,\n      propertyIsEnumerable = objectProto.propertyIsEnumerable,\n      unshift = arrayRef.unshift;\n  /** Used to set meta data on functions */\n\n  var defineProperty = function () {\n    // IE 8 only accepts DOM elements\n    try {\n      var o = {},\n          func = isNative(func = Object.defineProperty) && func,\n          result = func(o, o, o) && func;\n    } catch (e) {}\n\n    return result;\n  }();\n  /* Native method shortcuts for methods with the same name as other `lodash` methods */\n\n\n  var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n      nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n  /** Used to lookup a built-in constructor by [[Class]] */\n\n  var ctorByClass = {};\n  ctorByClass[arrayClass] = Array;\n  ctorByClass[boolClass] = Boolean;\n  ctorByClass[dateClass] = Date;\n  ctorByClass[funcClass] = Function;\n  ctorByClass[objectClass] = Object;\n  ctorByClass[numberClass] = Number;\n  ctorByClass[regexpClass] = RegExp;\n  ctorByClass[stringClass] = String;\n  /** Used to avoid iterating non-enumerable properties in IE < 9 */\n\n  var nonEnumProps = {};\n  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {\n    'constructor': true,\n    'toLocaleString': true,\n    'toString': true,\n    'valueOf': true\n  };\n  nonEnumProps[boolClass] = nonEnumProps[stringClass] = {\n    'constructor': true,\n    'toString': true,\n    'valueOf': true\n  };\n  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {\n    'constructor': true,\n    'toString': true\n  };\n  nonEnumProps[objectClass] = {\n    'constructor': true\n  };\n\n  (function () {\n    var length = shadowedProps.length;\n\n    while (length--) {\n      var key = shadowedProps[length];\n\n      for (var className in nonEnumProps) {\n        if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {\n          nonEnumProps[className][key] = false;\n        }\n      }\n    }\n  })();\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a `lodash` object which wraps the given value to enable intuitive\n   * method chaining.\n   *\n   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n   * and `unshift`\n   *\n   * Chaining is supported in custom builds as long as the `value` method is\n   * implicitly or explicitly included in the build.\n   *\n   * The chainable wrapper functions are:\n   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n   * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,\n   * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,\n   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n   * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,\n   * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,\n   * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,\n   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,\n   * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,\n   * and `zip`\n   *\n   * The non-chainable wrapper functions are:\n   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n   * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n   * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n   * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n   * `template`, `unescape`, `uniqueId`, and `value`\n   *\n   * The wrapper functions `first` and `last` return wrapped values when `n` is\n   * provided, otherwise they return unwrapped values.\n   *\n   * Explicit chaining can be enabled by using the `_.chain` method.\n   *\n   * @name _\n   * @constructor\n   * @category Chaining\n   * @param {*} value The value to wrap in a `lodash` instance.\n   * @returns {Object} Returns a `lodash` instance.\n   * @example\n   *\n   * var wrapped = _([1, 2, 3]);\n   *\n   * // returns an unwrapped value\n   * wrapped.reduce(function(sum, num) {\n   *   return sum + num;\n   * });\n   * // => 6\n   *\n   * // returns a wrapped value\n   * var squares = wrapped.map(function(num) {\n   *   return num * num;\n   * });\n   *\n   * _.isArray(squares);\n   * // => false\n   *\n   * _.isArray(squares.value());\n   * // => true\n   */\n\n\n  function lodash() {} // no operation performed\n\n  /**\n   * An object used to flag environments features.\n   *\n   * @static\n   * @memberOf _\n   * @type Object\n   */\n\n\n  var support = lodash.support = {};\n\n  (function () {\n    var ctor = function () {\n      this.x = 1;\n    },\n        object = {\n      '0': 1,\n      'length': 1\n    },\n        props = [];\n\n    ctor.prototype = {\n      'valueOf': 1,\n      'y': 1\n    };\n\n    for (var key in new ctor()) {\n      props.push(key);\n    }\n\n    for (key in arguments) {}\n    /**\n     * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n\n    support.argsClass = toString.call(arguments) == argsClass;\n    /**\n     * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);\n    /**\n     * Detect if `name` or `message` properties of `Error.prototype` are\n     * enumerable by default. (IE < 9, Safari < 5.1)\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');\n    /**\n     * Detect if `prototype` properties are enumerable by default.\n     *\n     * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\n     * (if the prototype or a property on the prototype has been set)\n     * incorrectly sets a function's `prototype` property [[Enumerable]]\n     * value to `true`.\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');\n    /**\n     * Detect if functions can be decompiled by `Function#toString`\n     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function () {\n      return this;\n    });\n    /**\n     * Detect if `Function#name` is supported (all but IE).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.funcNames = typeof Function.name == 'string';\n    /**\n     * Detect if `arguments` object indexes are non-enumerable\n     * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.nonEnumArgs = key != 0;\n    /**\n     * Detect if properties shadowing those on `Object.prototype` are non-enumerable.\n     *\n     * In IE < 9 an objects own properties, shadowing non-enumerable ones, are\n     * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.nonEnumShadows = !/valueOf/.test(props);\n    /**\n     * Detect if own properties are iterated after inherited properties (all but IE < 9).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.ownLast = props[0] != 'x';\n    /**\n     * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.\n     *\n     * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`\n     * and `splice()` functions that fail to remove the last element, `value[0]`,\n     * of array-like objects even though the `length` property is set to `0`.\n     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`\n     * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);\n    /**\n     * Detect lack of support for accessing string characters by index.\n     *\n     * IE < 8 can't access characters by index and IE 8 can only access\n     * characters by index on string literals.\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    support.unindexedChars = 'x'[0] + Object('x')[0] != 'xx';\n    /**\n     * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)\n     * and that the JS engine errors when attempting to coerce an object to\n     * a string without a `toString` function.\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n\n    try {\n      support.nodeClass = !(toString.call(document) == objectClass && !({\n        'toString': 0\n      } + ''));\n    } catch (e) {\n      support.nodeClass = true;\n    }\n  })(1);\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The template used to create iterator functions.\n   *\n   * @private\n   * @param {Object} data The data object used to populate the text.\n   * @returns {string} Returns the interpolated text.\n   */\n\n\n  var iteratorTemplate = function (obj) {\n    var __p = 'var index, iterable = ' + obj.firstArg + ', result = ' + obj.init + ';\\nif (!iterable) return result;\\n' + obj.top + ';';\n\n    if (obj.array) {\n      __p += '\\nvar length = iterable.length; index = -1;\\nif (' + obj.array + ') {  ';\n\n      if (support.unindexedChars) {\n        __p += '\\n  if (isString(iterable)) {\\n    iterable = iterable.split(\\'\\')\\n  }  ';\n      }\n\n      __p += '\\n  while (++index < length) {\\n    ' + obj.loop + ';\\n  }\\n}\\nelse {  ';\n    } else if (support.nonEnumArgs) {\n      __p += '\\n  var length = iterable.length; index = -1;\\n  if (length && isArguments(iterable)) {\\n    while (++index < length) {\\n      index += \\'\\';\\n      ' + obj.loop + ';\\n    }\\n  } else {  ';\n    }\n\n    if (support.enumPrototypes) {\n      __p += '\\n  var skipProto = typeof iterable == \\'function\\';\\n  ';\n    }\n\n    if (support.enumErrorProps) {\n      __p += '\\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\\n  ';\n    }\n\n    var conditions = [];\n\n    if (support.enumPrototypes) {\n      conditions.push('!(skipProto && index == \"prototype\")');\n    }\n\n    if (support.enumErrorProps) {\n      conditions.push('!(skipErrorProps && (index == \"message\" || index == \"name\"))');\n    }\n\n    if (obj.useHas && obj.keys) {\n      __p += '\\n  var ownIndex = -1,\\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\\n      length = ownProps ? ownProps.length : 0;\\n\\n  while (++ownIndex < length) {\\n    index = ownProps[ownIndex];\\n';\n\n      if (conditions.length) {\n        __p += '    if (' + conditions.join(' && ') + ') {\\n  ';\n      }\n\n      __p += obj.loop + ';    ';\n\n      if (conditions.length) {\n        __p += '\\n    }';\n      }\n\n      __p += '\\n  }  ';\n    } else {\n      __p += '\\n  for (index in iterable) {\\n';\n\n      if (obj.useHas) {\n        conditions.push(\"hasOwnProperty.call(iterable, index)\");\n      }\n\n      if (conditions.length) {\n        __p += '    if (' + conditions.join(' && ') + ') {\\n  ';\n      }\n\n      __p += obj.loop + ';    ';\n\n      if (conditions.length) {\n        __p += '\\n    }';\n      }\n\n      __p += '\\n  }    ';\n\n      if (support.nonEnumShadows) {\n        __p += '\\n\\n  if (iterable !== objectProto) {\\n    var ctor = iterable.constructor,\\n        isProto = iterable === (ctor && ctor.prototype),\\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\\n        nonEnum = nonEnumProps[className];\\n      ';\n\n        for (k = 0; k < 7; k++) {\n          __p += '\\n    index = \\'' + obj.shadowedProps[k] + '\\';\\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';\n\n          if (!obj.useHas) {\n            __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';\n          }\n\n          __p += ') {\\n      ' + obj.loop + ';\\n    }      ';\n        }\n\n        __p += '\\n  }    ';\n      }\n    }\n\n    if (obj.array || support.nonEnumArgs) {\n      __p += '\\n}';\n    }\n\n    __p += obj.bottom + ';\\nreturn result';\n    return __p;\n  };\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `_.bind` that creates the bound function and\n   * sets its meta data.\n   *\n   * @private\n   * @param {Array} bindData The bind data array.\n   * @returns {Function} Returns the new bound function.\n   */\n\n\n  function baseBind(bindData) {\n    var func = bindData[0],\n        partialArgs = bindData[2],\n        thisArg = bindData[4];\n\n    function bound() {\n      // `Function#bind` spec\n      // http://es5.github.io/#x15.3.4.5\n      if (partialArgs) {\n        // avoid `arguments` object deoptimizations by using `slice` instead\n        // of `Array.prototype.slice.call` and not assigning `arguments` to a\n        // variable as a ternary expression\n        var args = slice(partialArgs);\n        push.apply(args, arguments);\n      } // mimic the constructor's `return` behavior\n      // http://es5.github.io/#x13.2.2\n\n\n      if (this instanceof bound) {\n        // ensure `new bound` is an instance of `func`\n        var thisBinding = baseCreate(func.prototype),\n            result = func.apply(thisBinding, args || arguments);\n        return isObject(result) ? result : thisBinding;\n      }\n\n      return func.apply(thisArg, args || arguments);\n    }\n\n    setBindData(bound, bindData);\n    return bound;\n  }\n  /**\n   * The base implementation of `_.clone` without argument juggling or support\n   * for `thisArg` binding.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} [isDeep=false] Specify a deep clone.\n   * @param {Function} [callback] The function to customize cloning values.\n   * @param {Array} [stackA=[]] Tracks traversed source objects.\n   * @param {Array} [stackB=[]] Associates clones with source counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n\n\n  function baseClone(value, isDeep, callback, stackA, stackB) {\n    if (callback) {\n      var result = callback(value);\n\n      if (typeof result != 'undefined') {\n        return result;\n      }\n    } // inspect [[Class]]\n\n\n    var isObj = isObject(value);\n\n    if (isObj) {\n      var className = toString.call(value);\n\n      if (!cloneableClasses[className] || !support.nodeClass && isNode(value)) {\n        return value;\n      }\n\n      var ctor = ctorByClass[className];\n\n      switch (className) {\n        case boolClass:\n        case dateClass:\n          return new ctor(+value);\n\n        case numberClass:\n        case stringClass:\n          return new ctor(value);\n\n        case regexpClass:\n          result = ctor(value.source, reFlags.exec(value));\n          result.lastIndex = value.lastIndex;\n          return result;\n      }\n    } else {\n      return value;\n    }\n\n    var isArr = isArray(value);\n\n    if (isDeep) {\n      // check for circular references and return corresponding clone\n      var initedStack = !stackA;\n      stackA || (stackA = getArray());\n      stackB || (stackB = getArray());\n      var length = stackA.length;\n\n      while (length--) {\n        if (stackA[length] == value) {\n          return stackB[length];\n        }\n      }\n\n      result = isArr ? ctor(value.length) : {};\n    } else {\n      result = isArr ? slice(value) : assign({}, value);\n    } // add array properties assigned by `RegExp#exec`\n\n\n    if (isArr) {\n      if (hasOwnProperty.call(value, 'index')) {\n        result.index = value.index;\n      }\n\n      if (hasOwnProperty.call(value, 'input')) {\n        result.input = value.input;\n      }\n    } // exit for shallow clone\n\n\n    if (!isDeep) {\n      return result;\n    } // add the source value to the stack of traversed objects\n    // and associate it with its clone\n\n\n    stackA.push(value);\n    stackB.push(result); // recursively populate clone (susceptible to call stack limits)\n\n    (isArr ? baseEach : forOwn)(value, function (objValue, key) {\n      result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);\n    });\n\n    if (initedStack) {\n      releaseArray(stackA);\n      releaseArray(stackB);\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} prototype The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n\n\n  function baseCreate(prototype, properties) {\n    return isObject(prototype) ? nativeCreate(prototype) : {};\n  } // fallback for browsers without `Object.create`\n\n\n  if (!nativeCreate) {\n    baseCreate = function () {\n      function Object() {}\n\n      return function (prototype) {\n        if (isObject(prototype)) {\n          Object.prototype = prototype;\n          var result = new Object();\n          Object.prototype = null;\n        }\n\n        return result || root.Object();\n      };\n    }();\n  }\n  /**\n   * The base implementation of `_.createCallback` without support for creating\n   * \"_.pluck\" or \"_.where\" style callbacks.\n   *\n   * @private\n   * @param {*} [func=identity] The value to convert to a callback.\n   * @param {*} [thisArg] The `this` binding of the created callback.\n   * @param {number} [argCount] The number of arguments the callback accepts.\n   * @returns {Function} Returns a callback function.\n   */\n\n\n  function baseCreateCallback(func, thisArg, argCount) {\n    if (typeof func != 'function') {\n      return identity;\n    } // exit early for no `thisArg` or already bound by `Function#bind`\n\n\n    if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n      return func;\n    }\n\n    var bindData = func.__bindData__;\n\n    if (typeof bindData == 'undefined') {\n      if (support.funcNames) {\n        bindData = !func.name;\n      }\n\n      bindData = bindData || !support.funcDecomp;\n\n      if (!bindData) {\n        var source = fnToString.call(func);\n\n        if (!support.funcNames) {\n          bindData = !reFuncName.test(source);\n        }\n\n        if (!bindData) {\n          // checks if `func` references the `this` keyword and stores the result\n          bindData = reThis.test(source);\n          setBindData(func, bindData);\n        }\n      }\n    } // exit early if there are no `this` references or `func` is bound\n\n\n    if (bindData === false || bindData !== true && bindData[1] & 1) {\n      return func;\n    }\n\n    switch (argCount) {\n      case 1:\n        return function (value) {\n          return func.call(thisArg, value);\n        };\n\n      case 2:\n        return function (a, b) {\n          return func.call(thisArg, a, b);\n        };\n\n      case 3:\n        return function (value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n\n      case 4:\n        return function (accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n    }\n\n    return bind(func, thisArg);\n  }\n  /**\n   * The base implementation of `createWrapper` that creates the wrapper and\n   * sets its meta data.\n   *\n   * @private\n   * @param {Array} bindData The bind data array.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function baseCreateWrapper(bindData) {\n    var func = bindData[0],\n        bitmask = bindData[1],\n        partialArgs = bindData[2],\n        partialRightArgs = bindData[3],\n        thisArg = bindData[4],\n        arity = bindData[5];\n    var isBind = bitmask & 1,\n        isBindKey = bitmask & 2,\n        isCurry = bitmask & 4,\n        isCurryBound = bitmask & 8,\n        key = func;\n\n    function bound() {\n      var thisBinding = isBind ? thisArg : this;\n\n      if (partialArgs) {\n        var args = slice(partialArgs);\n        push.apply(args, arguments);\n      }\n\n      if (partialRightArgs || isCurry) {\n        args || (args = slice(arguments));\n\n        if (partialRightArgs) {\n          push.apply(args, partialRightArgs);\n        }\n\n        if (isCurry && args.length < arity) {\n          bitmask |= 16 & ~32;\n          return baseCreateWrapper([func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity]);\n        }\n      }\n\n      args || (args = arguments);\n\n      if (isBindKey) {\n        func = thisBinding[key];\n      }\n\n      if (this instanceof bound) {\n        thisBinding = baseCreate(func.prototype);\n        var result = func.apply(thisBinding, args);\n        return isObject(result) ? result : thisBinding;\n      }\n\n      return func.apply(thisBinding, args);\n    }\n\n    setBindData(bound, bindData);\n    return bound;\n  }\n  /**\n   * The base implementation of `_.merge` without argument juggling or support\n   * for `thisArg` binding.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {Function} [callback] The function to customize merging properties.\n   * @param {Array} [stackA=[]] Tracks traversed source objects.\n   * @param {Array} [stackB=[]] Associates values with source counterparts.\n   */\n\n\n  function baseMerge(object, source, callback, stackA, stackB) {\n    (isArray(source) ? forEach : forOwn)(source, function (source, key) {\n      var found,\n          isArr,\n          result = source,\n          value = object[key];\n\n      if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n        // avoid merging previously merged cyclic sources\n        var stackLength = stackA.length;\n\n        while (stackLength--) {\n          if (found = stackA[stackLength] == source) {\n            value = stackB[stackLength];\n            break;\n          }\n        }\n\n        if (!found) {\n          var isShallow;\n\n          if (callback) {\n            result = callback(value, source);\n\n            if (isShallow = typeof result != 'undefined') {\n              value = result;\n            }\n          }\n\n          if (!isShallow) {\n            value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};\n          } // add `source` and associated `value` to the stack of traversed objects\n\n\n          stackA.push(source);\n          stackB.push(value); // recursively merge objects and arrays (susceptible to call stack limits)\n\n          if (!isShallow) {\n            baseMerge(value, source, callback, stackA, stackB);\n          }\n        }\n      } else {\n        if (callback) {\n          result = callback(value, source);\n\n          if (typeof result == 'undefined') {\n            result = source;\n          }\n        }\n\n        if (typeof result != 'undefined') {\n          value = result;\n        }\n      }\n\n      object[key] = value;\n    });\n  }\n  /**\n   * Creates a function that, when called, either curries or invokes `func`\n   * with an optional `this` binding and partially applied arguments.\n   *\n   * @private\n   * @param {Function|string} func The function or method name to reference.\n   * @param {number} bitmask The bitmask of method flags to compose.\n   *  The bitmask may be composed of the following flags:\n   *  1 - `_.bind`\n   *  2 - `_.bindKey`\n   *  4 - `_.curry`\n   *  8 - `_.curry` (bound)\n   *  16 - `_.partial`\n   *  32 - `_.partialRight`\n   * @param {Array} [partialArgs] An array of arguments to prepend to those\n   *  provided to the new function.\n   * @param {Array} [partialRightArgs] An array of arguments to append to those\n   *  provided to the new function.\n   * @param {*} [thisArg] The `this` binding of `func`.\n   * @param {number} [arity] The arity of `func`.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n    var isBind = bitmask & 1,\n        isBindKey = bitmask & 2,\n        isCurry = bitmask & 4,\n        isCurryBound = bitmask & 8,\n        isPartial = bitmask & 16,\n        isPartialRight = bitmask & 32;\n\n    if (!isBindKey && !isFunction(func)) {\n      throw new TypeError();\n    }\n\n    if (isPartial && !partialArgs.length) {\n      bitmask &= ~16;\n      isPartial = partialArgs = false;\n    }\n\n    if (isPartialRight && !partialRightArgs.length) {\n      bitmask &= ~32;\n      isPartialRight = partialRightArgs = false;\n    }\n\n    var bindData = func && func.__bindData__;\n\n    if (bindData && bindData !== true) {\n      // clone `bindData`\n      bindData = slice(bindData);\n\n      if (bindData[2]) {\n        bindData[2] = slice(bindData[2]);\n      }\n\n      if (bindData[3]) {\n        bindData[3] = slice(bindData[3]);\n      } // set `thisBinding` is not previously bound\n\n\n      if (isBind && !(bindData[1] & 1)) {\n        bindData[4] = thisArg;\n      } // set if previously bound but not currently (subsequent curried functions)\n\n\n      if (!isBind && bindData[1] & 1) {\n        bitmask |= 8;\n      } // set curried arity if not yet set\n\n\n      if (isCurry && !(bindData[1] & 4)) {\n        bindData[5] = arity;\n      } // append partial left arguments\n\n\n      if (isPartial) {\n        push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n      } // append partial right arguments\n\n\n      if (isPartialRight) {\n        unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n      } // merge flags\n\n\n      bindData[1] |= bitmask;\n      return createWrapper.apply(null, bindData);\n    } // fast path for `_.bind`\n\n\n    var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;\n    return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n  }\n  /**\n   * Creates compiled iteration functions.\n   *\n   * @private\n   * @param {...Object} [options] The compile options object(s).\n   * @param {string} [options.array] Code to determine if the iterable is an array or array-like.\n   * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.\n   * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.\n   * @param {string} [options.args] A comma separated string of iteration function arguments.\n   * @param {string} [options.top] Code to execute before the iteration branches.\n   * @param {string} [options.loop] Code to execute in the object loop.\n   * @param {string} [options.bottom] Code to execute after the iteration branches.\n   * @returns {Function} Returns the compiled function.\n   */\n\n\n  function createIterator() {\n    // data properties\n    iteratorData.shadowedProps = shadowedProps; // iterator options\n\n    iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';\n    iteratorData.init = 'iterable';\n    iteratorData.useHas = true; // merge options into a template data object\n\n    for (var object, index = 0; object = arguments[index]; index++) {\n      for (var key in object) {\n        iteratorData[key] = object[key];\n      }\n    }\n\n    var args = iteratorData.args;\n    iteratorData.firstArg = /^[^,]+/.exec(args)[0]; // create the function factory\n\n    var factory = Function('baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' + 'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' + 'objectTypes, nonEnumProps, stringClass, stringProto, toString', 'return function(' + args + ') {\\n' + iteratorTemplate(iteratorData) + '\\n}'); // return the compiled function\n\n    return factory(baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);\n  }\n  /**\n   * Checks if `value` is a native function.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n   */\n\n\n  function isNative(value) {\n    return typeof value == 'function' && reNative.test(value);\n  }\n  /**\n   * Sets `this` binding data on a given function.\n   *\n   * @private\n   * @param {Function} func The function to set data on.\n   * @param {Array} value The data array to set.\n   */\n\n\n  var setBindData = !defineProperty ? noop : function (func, value) {\n    descriptor.value = value;\n    defineProperty(func, '__bindData__', descriptor);\n  };\n  /**\n   * A fallback implementation of `isPlainObject` which checks if a given value\n   * is an object created by the `Object` constructor, assuming objects created\n   * by the `Object` constructor have no inherited enumerable properties and that\n   * there are no `Object.prototype` extensions.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n   */\n\n  function shimIsPlainObject(value) {\n    var ctor, result; // avoid non Object objects, `arguments` objects, and DOM elements\n\n    if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value)) {\n      return false;\n    } // IE < 9 iterates inherited properties before own properties. If the first\n    // iterated property is an object's own property then there are no inherited\n    // enumerable properties.\n\n\n    if (support.ownLast) {\n      forIn(value, function (value, key, object) {\n        result = hasOwnProperty.call(object, key);\n        return false;\n      });\n      return result !== false;\n    } // In most environments an object's own properties are iterated before\n    // its inherited properties. If the last iterated property is an object's\n    // own property then there are no inherited enumerable properties.\n\n\n    forIn(value, function (value, key) {\n      result = key;\n    });\n    return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Checks if `value` is an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n   * @example\n   *\n   * (function() { return _.isArguments(arguments); })(1, 2, 3);\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n\n\n  function isArguments(value) {\n    return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;\n  } // fallback for browsers that can't detect `arguments` objects by [[Class]]\n\n\n  if (!support.argsClass) {\n    isArguments = function (value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;\n    };\n  }\n  /**\n   * Checks if `value` is an array.\n   *\n   * @static\n   * @memberOf _\n   * @type Function\n   * @category Objects\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n   * @example\n   *\n   * (function() { return _.isArray(arguments); })();\n   * // => false\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   */\n\n\n  var isArray = nativeIsArray || function (value) {\n    return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;\n  };\n  /**\n   * A fallback implementation of `Object.keys` which produces an array of the\n   * given object's own enumerable property names.\n   *\n   * @private\n   * @type Function\n   * @param {Object} object The object to inspect.\n   * @returns {Array} Returns an array of property names.\n   */\n\n\n  var shimKeys = createIterator({\n    'args': 'object',\n    'init': '[]',\n    'top': 'if (!(objectTypes[typeof object])) return result',\n    'loop': 'result.push(index)'\n  });\n  /**\n   * Creates an array composed of the own enumerable property names of an object.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to inspect.\n   * @returns {Array} Returns an array of property names.\n   * @example\n   *\n   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n   * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n   */\n\n  var keys = !nativeKeys ? shimKeys : function (object) {\n    if (!isObject(object)) {\n      return [];\n    }\n\n    if (support.enumPrototypes && typeof object == 'function' || support.nonEnumArgs && object.length && isArguments(object)) {\n      return shimKeys(object);\n    }\n\n    return nativeKeys(object);\n  };\n  /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */\n\n  var eachIteratorOptions = {\n    'args': 'collection, callback, thisArg',\n    'top': \"callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)\",\n    'array': \"typeof length == 'number'\",\n    'keys': keys,\n    'loop': 'if (callback(iterable[index], index, collection) === false) return result'\n  };\n  /** Reusable iterator options for `assign` and `defaults` */\n\n  var defaultsIteratorOptions = {\n    'args': 'object, source, guard',\n    'top': 'var args = arguments,\\n' + '    argsIndex = 0,\\n' + \"    argsLength = typeof guard == 'number' ? 2 : args.length;\\n\" + 'while (++argsIndex < argsLength) {\\n' + '  iterable = args[argsIndex];\\n' + '  if (iterable && objectTypes[typeof iterable]) {',\n    'keys': keys,\n    'loop': \"if (typeof result[index] == 'undefined') result[index] = iterable[index]\",\n    'bottom': '  }\\n}'\n  };\n  /** Reusable iterator options for `forIn` and `forOwn` */\n\n  var forOwnIteratorOptions = {\n    'top': 'if (!objectTypes[typeof iterable]) return result;\\n' + eachIteratorOptions.top,\n    'array': false\n  };\n  /**\n   * A function compiled to iterate `arguments` objects, arrays, objects, and\n   * strings consistenly across environments, executing the callback for each\n   * element in the collection. The callback is bound to `thisArg` and invoked\n   * with three arguments; (value, index|key, collection). Callbacks may exit\n   * iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @type Function\n   * @param {Array|Object|string} collection The collection to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {*} [thisArg] The `this` binding of `callback`.\n   * @returns {Array|Object|string} Returns `collection`.\n   */\n\n  var baseEach = createIterator(eachIteratorOptions);\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Assigns own enumerable properties of source object(s) to the destination\n   * object. Subsequent sources will overwrite property assignments of previous\n   * sources. If a callback is provided it will be executed to produce the\n   * assigned values. The callback is bound to `thisArg` and invoked with two\n   * arguments; (objectValue, sourceValue).\n   *\n   * @static\n   * @memberOf _\n   * @type Function\n   * @alias extend\n   * @category Objects\n   * @param {Object} object The destination object.\n   * @param {...Object} [source] The source objects.\n   * @param {Function} [callback] The function to customize assigning values.\n   * @param {*} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns the destination object.\n   * @example\n   *\n   * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n   * // => { 'name': 'fred', 'employer': 'slate' }\n   *\n   * var defaults = _.partialRight(_.assign, function(a, b) {\n   *   return typeof a == 'undefined' ? b : a;\n   * });\n   *\n   * var object = { 'name': 'barney' };\n   * defaults(object, { 'name': 'fred', 'employer': 'slate' });\n   * // => { 'name': 'barney', 'employer': 'slate' }\n   */\n\n  var assign = createIterator(defaultsIteratorOptions, {\n    'top': defaultsIteratorOptions.top.replace(';', ';\\n' + \"if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\\n\" + '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\\n' + \"} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\\n\" + '  callback = args[--argsLength];\\n' + '}'),\n    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'\n  });\n  /**\n   * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n   * be cloned, otherwise they will be assigned by reference. If a callback\n   * is provided it will be executed to produce the cloned values. If the\n   * callback returns `undefined` cloning will be handled by the method instead.\n   * The callback is bound to `thisArg` and invoked with one argument; (value).\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {*} value The value to clone.\n   * @param {boolean} [isDeep=false] Specify a deep clone.\n   * @param {Function} [callback] The function to customize cloning values.\n   * @param {*} [thisArg] The `this` binding of `callback`.\n   * @returns {*} Returns the cloned value.\n   * @example\n   *\n   * var characters = [\n   *   { 'name': 'barney', 'age': 36 },\n   *   { 'name': 'fred',   'age': 40 }\n   * ];\n   *\n   * var shallow = _.clone(characters);\n   * shallow[0] === characters[0];\n   * // => true\n   *\n   * var deep = _.clone(characters, true);\n   * deep[0] === characters[0];\n   * // => false\n   *\n   * _.mixin({\n   *   'clone': _.partialRight(_.clone, function(value) {\n   *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n   *   })\n   * });\n   *\n   * var clone = _.clone(document.body);\n   * clone.childNodes.length;\n   * // => 0\n   */\n\n  function clone(value, isDeep, callback, thisArg) {\n    // allows working with \"Collections\" methods without using their `index`\n    // and `collection` arguments for `isDeep` and `callback`\n    if (typeof isDeep != 'boolean' && isDeep != null) {\n      thisArg = callback;\n      callback = isDeep;\n      isDeep = false;\n    }\n\n    return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n  }\n  /**\n   * Iterates over own and inherited enumerable properties of an object,\n   * executing the callback for each property. The callback is bound to `thisArg`\n   * and invoked with three arguments; (value, key, object). Callbacks may exit\n   * iteration early by explicitly returning `false`.\n   *\n   * @static\n   * @memberOf _\n   * @type Function\n   * @category Objects\n   * @param {Object} object The object to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {*} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * function Shape() {\n   *   this.x = 0;\n   *   this.y = 0;\n   * }\n   *\n   * Shape.prototype.move = function(x, y) {\n   *   this.x += x;\n   *   this.y += y;\n   * };\n   *\n   * _.forIn(new Shape, function(value, key) {\n   *   console.log(key);\n   * });\n   * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n   */\n\n\n  var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {\n    'useHas': false\n  });\n  /**\n   * Iterates over own enumerable properties of an object, executing the callback\n   * for each property. The callback is bound to `thisArg` and invoked with three\n   * arguments; (value, key, object). Callbacks may exit iteration early by\n   * explicitly returning `false`.\n   *\n   * @static\n   * @memberOf _\n   * @type Function\n   * @category Objects\n   * @param {Object} object The object to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {*} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n   *   console.log(key);\n   * });\n   * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n   */\n\n  var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);\n  /**\n   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n   * length of `0` and objects with no own enumerable properties are considered\n   * \"empty\".\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Array|Object|string} value The value to inspect.\n   * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n   * @example\n   *\n   * _.isEmpty([1, 2, 3]);\n   * // => false\n   *\n   * _.isEmpty({});\n   * // => true\n   *\n   * _.isEmpty('');\n   * // => true\n   */\n\n  function isEmpty(value) {\n    var result = true;\n\n    if (!value) {\n      return result;\n    }\n\n    var className = toString.call(value),\n        length = value.length;\n\n    if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {\n      return !length;\n    }\n\n    forOwn(value, function () {\n      return result = false;\n    });\n    return result;\n  }\n  /**\n   * Checks if `value` is a function.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   */\n\n\n  function isFunction(value) {\n    return typeof value == 'function';\n  } // fallback for older versions of Chrome and Safari\n\n\n  if (isFunction(/x/)) {\n    isFunction = function (value) {\n      return typeof value == 'function' && toString.call(value) == funcClass;\n    };\n  }\n  /**\n   * Checks if `value` is the language type of Object.\n   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(1);\n   * // => false\n   */\n\n\n  function isObject(value) {\n    // check if the value is the ECMAScript language type of Object\n    // http://es5.github.io/#x8\n    // and avoid a V8 bug\n    // http://code.google.com/p/v8/issues/detail?id=2291\n    return !!(value && objectTypes[typeof value]);\n  }\n  /**\n   * Checks if `value` is an object created by the `Object` constructor.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n   * @example\n   *\n   * function Shape() {\n   *   this.x = 0;\n   *   this.y = 0;\n   * }\n   *\n   * _.isPlainObject(new Shape);\n   * // => false\n   *\n   * _.isPlainObject([1, 2, 3]);\n   * // => false\n   *\n   * _.isPlainObject({ 'x': 0, 'y': 0 });\n   * // => true\n   */\n\n\n  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {\n    if (!(value && toString.call(value) == objectClass) || !support.argsClass && isArguments(value)) {\n      return false;\n    }\n\n    var valueOf = value.valueOf,\n        objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n    return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);\n  };\n  /**\n   * Checks if `value` is a string.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n   * @example\n   *\n   * _.isString('fred');\n   * // => true\n   */\n\n  function isString(value) {\n    return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;\n  }\n  /**\n   * Recursively merges own enumerable properties of the source object(s), that\n   * don't resolve to `undefined` into the destination object. Subsequent sources\n   * will overwrite property assignments of previous sources. If a callback is\n   * provided it will be executed to produce the merged values of the destination\n   * and source properties. If the callback returns `undefined` merging will\n   * be handled by the method instead. The callback is bound to `thisArg` and\n   * invoked with two arguments; (objectValue, sourceValue).\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The destination object.\n   * @param {...Object} [source] The source objects.\n   * @param {Function} [callback] The function to customize merging properties.\n   * @param {*} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns the destination object.\n   * @example\n   *\n   * var names = {\n   *   'characters': [\n   *     { 'name': 'barney' },\n   *     { 'name': 'fred' }\n   *   ]\n   * };\n   *\n   * var ages = {\n   *   'characters': [\n   *     { 'age': 36 },\n   *     { 'age': 40 }\n   *   ]\n   * };\n   *\n   * _.merge(names, ages);\n   * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n   *\n   * var food = {\n   *   'fruits': ['apple'],\n   *   'vegetables': ['beet']\n   * };\n   *\n   * var otherFood = {\n   *   'fruits': ['banana'],\n   *   'vegetables': ['carrot']\n   * };\n   *\n   * _.merge(food, otherFood, function(a, b) {\n   *   return _.isArray(a) ? a.concat(b) : undefined;\n   * });\n   * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n   */\n\n\n  function merge(object) {\n    var args = arguments,\n        length = 2;\n\n    if (!isObject(object)) {\n      return object;\n    } // allows working with `_.reduce` and `_.reduceRight` without using\n    // their `index` and `collection` arguments\n\n\n    if (typeof args[2] != 'number') {\n      length = args.length;\n    }\n\n    if (length > 3 && typeof args[length - 2] == 'function') {\n      var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n    } else if (length > 2 && typeof args[length - 1] == 'function') {\n      callback = args[--length];\n    }\n\n    var sources = slice(arguments, 1, length),\n        index = -1,\n        stackA = getArray(),\n        stackB = getArray();\n\n    while (++index < length) {\n      baseMerge(object, sources[index], callback, stackA, stackB);\n    }\n\n    releaseArray(stackA);\n    releaseArray(stackB);\n    return object;\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Iterates over elements of a collection, executing the callback for each\n   * element. The callback is bound to `thisArg` and invoked with three arguments;\n   * (value, index|key, collection). Callbacks may exit iteration early by\n   * explicitly returning `false`.\n   *\n   * Note: As with other \"Collections\" methods, objects with a `length` property\n   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n   * may be used for object iteration.\n   *\n   * @static\n   * @memberOf _\n   * @alias each\n   * @category Collections\n   * @param {Array|Object|string} collection The collection to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {*} [thisArg] The `this` binding of `callback`.\n   * @returns {Array|Object|string} Returns `collection`.\n   * @example\n   *\n   * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n   * // => logs each number and returns '1,2,3'\n   *\n   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n   * // => logs each number and returns the object (property order is not guaranteed across environments)\n   */\n\n\n  function forEach(collection, callback, thisArg) {\n    if (callback && typeof thisArg == 'undefined' && isArray(collection)) {\n      var index = -1,\n          length = collection.length;\n\n      while (++index < length) {\n        if (callback(collection[index], index, collection) === false) {\n          break;\n        }\n      }\n    } else {\n      baseEach(collection, callback, thisArg);\n    }\n\n    return collection;\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates an array with all falsey values removed. The values `false`, `null`,\n   * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to compact.\n   * @returns {Array} Returns a new array of filtered values.\n   * @example\n   *\n   * _.compact([0, 1, false, 2, '', 3]);\n   * // => [1, 2, 3]\n   */\n\n\n  function compact(array) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n\n      if (value) {\n        result.push(value);\n      }\n    }\n\n    return result;\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a function that, when called, invokes `func` with the `this`\n   * binding of `thisArg` and prepends any additional `bind` arguments to those\n   * provided to the bound function.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to bind.\n   * @param {*} [thisArg] The `this` binding of `func`.\n   * @param {...*} [arg] Arguments to be partially applied.\n   * @returns {Function} Returns the new bound function.\n   * @example\n   *\n   * var func = function(greeting) {\n   *   return greeting + ' ' + this.name;\n   * };\n   *\n   * func = _.bind(func, { 'name': 'fred' }, 'hi');\n   * func();\n   * // => 'hi fred'\n   */\n\n\n  function bind(func, thisArg) {\n    return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * This method returns the first argument provided to it.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'name': 'fred' };\n   * _.identity(object) === object;\n   * // => true\n   */\n\n\n  function identity(value) {\n    return value;\n  }\n  /**\n   * A no-operation function.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @example\n   *\n   * var object = { 'name': 'fred' };\n   * _.noop(object) === undefined;\n   * // => true\n   */\n\n\n  function noop() {} // no operation performed\n\n  /*--------------------------------------------------------------------------*/\n\n\n  lodash.assign = assign;\n  lodash.bind = bind;\n  lodash.compact = compact;\n  lodash.forEach = forEach;\n  lodash.forIn = forIn;\n  lodash.forOwn = forOwn;\n  lodash.keys = keys;\n  lodash.merge = merge;\n  lodash.each = forEach;\n  lodash.extend = assign;\n  /*--------------------------------------------------------------------------*/\n  // add functions that return unwrapped values when chaining\n\n  lodash.clone = clone;\n  lodash.identity = identity;\n  lodash.isArguments = isArguments;\n  lodash.isArray = isArray;\n  lodash.isEmpty = isEmpty;\n  lodash.isFunction = isFunction;\n  lodash.isObject = isObject;\n  lodash.isPlainObject = isPlainObject;\n  lodash.isString = isString;\n  lodash.noop = noop;\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The semantic version number.\n   *\n   * @static\n   * @memberOf _\n   * @type string\n   */\n\n  lodash.VERSION = '2.4.1';\n  /*--------------------------------------------------------------------------*/\n\n  if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = lodash)._ = lodash;\n    }\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}